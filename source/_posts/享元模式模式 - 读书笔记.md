---
title: 享元模式模式 - 读书笔记
date: 2016年10月4日17:29:26
categories: 读书笔记
tags: [Android源码设计模式解析与实战，读书笔记，Android]
---

# 来自Android源码设计模式解析与实战的第二十二章，Android源码中的享元模式

---

## Handler的工作原理

在此之前，我们需要了解Message和MessageQueue

## 1. Message

Android应用是事件驱动的，每个事件会转化成一个系统消息，即Message。消息中包含了事件相关的信息以及这个消息的处理人Handler。每个进程都有一个默认的消息队列，也就是我们的MessageQueue，这个消息队列维护了一个待处理的消息列表，有一个消息循环不断地从这个队列中取出消息、处理消息 ，这样就使得应用动态的运作起来。

我们来看看Message.obtain()的实现

```java
  public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
```

可以看到Message是一个类似链表的结构，用sPool去存储下个Message。接着再看recycle方法

```java
	public void recycle() {
        if (isInUse()) {
            if (gCheckRecycle) {
                throw new IllegalStateException();
            }
            return;
        }
        recycleUnchecked();
    }
	void recycleUnchecked() {
        // Mark the message as in use while it remains in the recycled object pool.
        // Clear out all other details.
        flags = FLAG_IN_USE;
        what = 0;
        arg1 = 0;
        arg2 = 0;
        obj = null;
        replyTo = null;
        sendingUid = -1;
        when = 0;
        target = null;
        callback = null;
        data = null;

        synchronized (sPoolSync) {
            if (sPoolSize < MAX_POOL_SIZE) {
                next = sPool;
                sPool = this;
                sPoolSize++;
            }
        }
    }
```

recycle函数会将一个Message对象回收到链表中，并将自身清空后添加到链表的表头。

## 2. Handler

我们先来看看Handler构造函数

```java
	public Handler(Looper looper, Callback callback, boolean async) {
         mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
    }
```

这里看到，Handler会通过Looper.getLooper()来获取Looper对象 ，并与之关联。最重要的是Looper持有消息队列mQueue。接下来我们看看Looper中几个常见的方法的源码

## 3. Looper

```java
	public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }

	private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

	public static void loop() {
        final Looper me = myLooper();
        final MessageQueue queue = me.mQueue;
        for (;;) {
            Message msg = queue.next(); // might block
            msg.target.dispatchMessage(msg);
            msg.recycleUnchecked();
        }
    }
```

其中，loop方法的实质就是建立一个死循环，然后通过从消息队列中逐个取出消息，最后就是处理消息、回收消息的过程。

我们直接看看queue的next函数

```java
Message next() {
        for (;;) {
         		nativePollOnce(mPtr, nextPollTimeoutMillis);
                synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                if (msg != null && msg.target == null) {
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null && !msg.isAsynchronous());
                }
        }
    }
```

next函数的基本思路就是从消息队列中依次取出消息，如果这个消息到了执行时间，那么就将消息返回给Looper，并将消息队列链表的指针后移。

但是在消息队列获取消息之前，还有个nativePollOnce函数的调用，第一个参数是mPtr，这个是什么呢？mPtr的初始化是在MessageQueue的构造函数中

```java
	MessageQueue(boolean quitAllowed) {
        mQuitAllowed = quitAllowed;
        mPtr = nativeInit();
    }
```

可以看到mPtr的值是nativeInit函数返回的，该函数在android_os_MessageQueue.cpp类中

```c++
static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {
    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();
    if (!nativeMessageQueue) {
        jniThrowRuntimeException(env, "Unable to allocate native queue");
        return 0;
    }

    nativeMessageQueue->incStrong(env);
    return reinterpret_cast<jlong>(nativeMessageQueue);
}
```

我们看到nativeInit中会构造一个NativeMessageQueue对象，并将之转为一个long型，并且返回给java层中，而当java层需要与Native层的MessageQueue通信时只要把这个long值传递给Native层，然后Native通过reinterpret_cast将传递来的long转换为NativeMessageQueue指针即可得到这个NativeMessageQueue对象指针。

接着我们来看NativeMessageQueue的构造函数

```c++
NativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) {
    mLooper = Looper::getForThread();
    if (mLooper == NULL) {
        mLooper = new Looper(false);
        Looper::setForThread(mLooper);
    }
}
```

这里创建了一个Native层的Looper，然后这个Looper设置给当前进程。

## 4. 小结

* 首先构造Java层的Looper对象，Looper对象又会在构造函数中创建Java层的MessageQueue对象
* Java层的MessageQueue的构造函数中调用nativeInit函数初始化Native层的NativeMessageQueue，NativeMessageQueue的构造函数又会创建Native层的Looper，并且通过管道和epoll建立一套消息机制
* Native层构建完毕，将NativeMessageQueue对象转换为一个long型存储到Java层的MessageQueue的mPtr中
* 启动Java层的消息循环，不断读取、处理消息


Android是支持纯Native开发的，因此在Native层实现一套消息机制是必须的。另外，Android系统的核心组件也是运行在Native层，各组件的通信也是通过Native层的消息机制。
