---
title: 适配器模式 - 读书笔记
date: 2016年7月11日22:47:45
categories: 读书笔记
tags: [Android源码设计模式解析与实战，读书笔记，Android]
---

# 来自Android源码设计模式解析与实战的第二十章，得心应手的“粘合剂”——适配器模式

---

## 1. ListView和Adapter

ListView中并没有Adapter相关的成员变量 ，其实Adapter在ListView的父类AbsListView中。

由于每次修改布局后ListView会调用onLayout，所以直接看这部分代码

```java
 	@Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        super.onLayout(changed, l, t, r, b);
        mInLayout = true;
        final int childCount = getChildCount();
        if (changed) {
            for (int i = 0; i < childCount; i++) {
                getChildAt(i).forceLayout();
            }
            mRecycler.markChildrenDirty();
        }
        layoutChildren();
        mInLayout = false;
        mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;
        if (mFastScroll != null) {
            mFastScroll.onItemCountChanged(getChildCount(), mItemCount);
        }
    }
```

AbsListView中没有实现layoutChildren，所以我们查看ListView中的对应方法

```java
	@Override
    protected void layoutChildren() {
        final boolean blockLayoutRequests = mBlockLayoutRequests;
       	...
        try {
            super.layoutChildren();
            invalidate();
			...
            switch (mLayoutMode) {
            ...
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            ...
            }
    }
```

简单来说，它会根据mLayoutMode来决定布局，我们这里就只看fillUp方法

```java
	private View fillUp(int pos, int nextBottom) {
        View selectedView = null;

        int end = 0;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            end = mListPadding.top;
        }

        while (nextBottom > end && pos >= 0) {
            // is this the selected item?
            boolean selected = pos == mSelectedPosition;
            View child = makeAndAddView(pos, nextBottom, false, mListPadding.left, selected);
            nextBottom = child.getTop() - mDividerHeight;
            if (selected) {
                selectedView = child;
            }
            pos--;
        }

        mFirstPosition = pos + 1;
        setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);
        return selectedView;
    }
```

布局中会调用makeAndAddView来生成对应的view

```java
	private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
            boolean selected) {
        View child;
        if (!mDataChanged) {
            child = mRecycler.getActiveView(position);
            if (child != null) {
                setupChild(child, position, y, flow, childrenLeft, selected, true);
                return child;
            }
        }
        child = obtainView(position, mIsScrap);
        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);
        return child;
    }
```

这里有两种情况

* 如果数据没变动，则通过getActiveView取得缓存的view
* 否则都通过obtainView获得对应view

obtainView是AbsListView的核心方法

```java
	View obtainView(int position, boolean[] isScrap) {
        isScrap[0] = false;
		...
        final View scrapView = mRecycler.getScrapView(position);
        final View child = mAdapter.getView(position, scrapView, this);
        return child;
    }
```

这样，不论scrapView在不在缓存中，都会调用对应Adapter中的getView方法。、

## 2. RecyclerView

RecyclerView和ListView都使用了Adapter和观察者模式

```java
	public void setAdapter(Adapter adapter) {
        setLayoutFrozen(false);
        setAdapterInternal(adapter, false, true);
        requestLayout();
    }

	private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,
            boolean removeAndRecycleViews) {
        ...
        mAdapterHelper.reset();
        final Adapter oldAdapter = mAdapter;
        mAdapter = adapter;
        if (adapter != null) {
            adapter.registerAdapterDataObserver(mObserver);
            adapter.onAttachedToRecyclerView(this);
        }
        if (mLayout != null) {
            mLayout.onAdapterChanged(oldAdapter, mAdapter);
        }
        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);
        mState.mStructureChanged = true;
        markKnownViewsInvalid();
    }
```

这里不难看出registerAdapterDataObserver注册后，让变化时会调用它的onChange接口，通过requestLayout方法重新布局。那我们需要看onLayout方法。

```java
	@Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        eatRequestLayout();
        dispatchLayout();
        resumeRequestLayout(false);
        mFirstLayoutComplete = true;
    }

	void dispatchLayout() {
        ...
        mLayout.onLayoutChildren(mRecycler, mState);
      	...
    }
```

这里的mLayout就是LayoutManager。以LinearLayoutManager为例，

```java
	@Override
    public void onLayoutChildren(RecyclerView.Recycler recycler,RecyclerView.State state) {
       	...
        if (mAnchorInfo.mLayoutFromEnd) {
            ...
        } else {
            // fill towards end
            updateLayoutStateToFillEnd(mAnchorInfo);
            mLayoutState.mExtra = extraForEnd;
            fill(recycler, mLayoutState, state, false);
            endOffset = mLayoutState.mOffset;
            final int lastElement = mLayoutState.mCurrentPosition;
            if (mLayoutState.mAvailable > 0) {
                extraForStart += mLayoutState.mAvailable;
            }
            // fill towards start
            updateLayoutStateToFillStart(mAnchorInfo);
            mLayoutState.mExtra = extraForStart;
            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
            fill(recycler, mLayoutState, state, false);
            startOffset = mLayoutState.mOffset;
        }
      	...
    }

	int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {
        // max offset we should set is mFastScroll + available
        final int start = layoutState.mAvailable;
        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
        LayoutChunkResult layoutChunkResult = new LayoutChunkResult();
        while ((layoutState.mInfinite||remainingSpace>0)&&layoutState.hasMore(state)) {
            layoutChunkResult.resetInternal();
            layoutChunk(recycler, state, layoutState, layoutChunkResult);
            if (layoutChunkResult.mFinished) {
                break;
            }
            ...
        }
        return start - layoutState.mAvailable;
    }
```

onLayoutChilden会调用fill函数，在fill函数中又会循环调用layoutChunk函数进行布局。而layoutChunk中通过itemView的高宽，算出对应坐标，最后调用layoutDecorated函数实现布局。

```java
	public void layoutDecorated(View child, int left, int top, int right, int bottom) {
            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
            child.layout(left + insets.left, top + insets.top, right - insets.right,
                    bottom - insets.bottom);
    }
```

上述代码可以看出，布局的职责从RecyclerView分离到LayoutManager中。

再看看layoutChunk中获取view时调用的layoutState#next方法

```java
	View next(RecyclerView.Recycler recycler) {
            if (mScrapList != null) {
                return nextViewFromScrapList();
            }
            final View view = recycler.getViewForPosition(mCurrentPosition);
            mCurrentPosition += mItemDirection;
            return view;
   	}
```

其中getViewForPosition方法就是用户获取对应item view的。

```java
View getViewForPosition(int position, boolean dryRun) {
            ViewHolder holder = null;
            // 0) If there is a changed scrap, try to find from there
            if (mState.isPreLayout()) {
                holder = getChangedScrapViewForPosition(position);
                fromScrap = holder != null;
            }
            // 1) Find from scrap by position
            if (holder == null) {
                holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun);
                ...
            }
            if (holder == null) {
                ...
                if (holder == null) {
                    holder = mAdapter.createViewHolder(RecyclerView.this, type);
                }
            }
  			mAdapter.bindViewHolder(holder, offsetPosition);
           	...
            return holder.itemView;
        }
```

简单流程为：

* 从mChangedScrap获取缓存ViewHolder，getChangedScrapViewForPosition
* 从mAttachedScrap获取缓存ViewHolder，getScrapViewForPosition
* 若还是空，则调用mAdapter中的createViewHolder创建对应view
* 最后是通过mAdapter中的bindViewHolder进行数据绑定